#ifndef __MATHUTIL_H__
#define __MATHUTIL_H__

#include <H3DUtil/Vec3f.h>
#include <H3DUtil/Matrix4f.h>

namespace MathUtil
{
	using namespace H3DUtil;

	/*
	The gluLookAt subroutine multiplies the top matrix of the current matrix stack with a matrix M (computed below), whose effect is to place the eye point at the origin, 
	the center point along the negative z axis, and the up vector somewhere in the YZ plane, above the z axis. This is done through pure rotation and translation, preserving all distance metrics.

	The matrix M generated by the OpenGL could be computed as follows:

	Let E be the 3d column vector (eyeX, eyeY, eyeZ).
	Let C be the 3d column vector (centerX, centerY, centerZ).
	Let U be the 3d column vector (upX, upY, upZ).
	Compute L = C - E.
	Normalize L.
	Compute S = L x U.
	Normalize S.
	Compute U' = S x L.

	M is the matrix whose columns are, in order:

	(S, 0), (U', 0), (-L, 0), (-E, 1)  (all column vectors)
	*/
	/* http://msdn.microsoft.com/en-us/library/windows/desktop/bb281711%28v=vs.85%29.aspx
	zaxis = normal(cameraPosition - cameraTarget)
	xaxis = normal(cross(cameraUpVector, zaxis))
	yaxis = cross(zaxis, xaxis)

	*/
	H3D::Matrix4f CreateLookAt(Vec3f eye, Vec3f lookAt, Vec3f up)
	{
		Vec3f zAxis = eye - lookAt;
		zAxis.normalizeSafe();

		up.normalizeSafe();
		Vec3f xAxis = up.crossProduct(zAxis);
		xAxis.normalizeSafe();

		Vec3f yAxis = zAxis.crossProduct(xAxis);
		yAxis.normalizeSafe();

		//Column major
		Matrix4f r
			(
			xAxis.x,				yAxis.x,				zAxis.x,					0.0f,
			xAxis.y,				yAxis.y,				zAxis.y,					0.0f,
			xAxis.z,				yAxis.z,				zAxis.z,					0.0f,
			-xAxis.dotProduct(eye), -yAxis.dotProduct(eye), -zAxis.dotProduct(eye),		1.0f
			);

		//Transpose to turn into row major
		return r.transpose();
	}

	//http://stackoverflow.com/questions/3498581/in-opengl-what-is-the-simplest-way-to-create-a-perspective-view-using-only-open
	/* 
	//NOTE: THIS IS GLSL CODE. GLSL uses column major, H3D uses row major. We'll transpose when sending this into the shader later.
	mat4 CreatePerspectiveMatrix(in float fov, in float aspect, in float near, in float far)
	{
	mat4 m = mat4(0.0);

	float angle = (fov / 180.0f) * PI;
	float f = 1.0f / tan( angle * 0.5f );

	//Note, matrices are accessed like 2D arrays in C.
	//They are column major, i.e m[y][x]

	m[0][0] = f / aspect;
	m[1][1] = f;
	m[2][2] = (far + near) / (near - far);
	m[2][3] = -1.0f;
	m[3][2] = (2.0f * far*near) / (near - far);

	return m;
	}
	}*/

	/*
	Create row-major perspective projection matrix
	*/
	Matrix4f CreatePerspectiveProjection(float fovY, float aspectRatio, float zNear, float zFar)
	{
		float angle = (fovY/180.0f) * static_cast<float>(H3D::Constants::pi); //Unnecessary cast, but removes compile warning.
		float f = 1.0f / tan(angle*0.5f);

		float nearMinusFar = (zNear-zFar);
		float nearPlusFar = (zFar+zNear);
		float twoNearTimesFar = (2.0f * (zFar*zNear));

		//This is column major
		Matrix4f m(
			f/aspectRatio,	0.0f,	0.0f,							0.0f,
			0.0f,			f,		0.0f,							0.0f,
			0.0f,			0.0f,	nearPlusFar/nearMinusFar,		-1.0f,
			0.0f,			0.0f,	twoNearTimesFar/nearMinusFar,	0.0f
			);

		//Transpose to turn it into row major
		return m.transpose();
	}

	float DegreesToRadians(float degrees) {
		return degrees * static_cast<float>(H3D::Constants::pi/180.0); //Unnecessary cast, but removes compile warning.
	}

	float RadiansToDegrees(float radians) {
		return radians * static_cast<float>(180.0/H3D::Constants::pi); //Unnecessary cast, but removes compile warning.
	}
}

#endif